import os
import shutil
import pyzipper
from datetime import datetime, timedelta
import nc_py_api
import json
import click
import sys
from schwachstellenmgmt.secret_functions import generate_random_password, create_one_time_secret_link
from schwachstellenmgmt.email_functions import send_NextcloudPassword_email, send_link_and_zipPassword_email

CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"], show_default=True)


def read_credentials(credentials_path: str) -> dict:
    """
    The method reads the access data from the credentials.txt file
    
    Args:
    credentials_path (str): The file path to the credentials file.

    Returns:
    dict: A dictionary containing the access data read from the credentials file, where keys are credential identifiers
    and values are the corresponding credentials.
    """

    try:
        with open(credentials_path, "r") as file:
            lines = file.readlines()
            credentials = {}
            for line in lines:
                key, value = line.strip().split("=")
                credentials[key] = value
            return credentials
    except Exception as e:
        print("credentials.txt file not found or contains an error: ", e)
        

def sort_pdfs(pdf_folder: str, IP_Email_json: str, upload_folder: str) -> None:
    """
    The method organizes PDF files from the pdf_folder into subfolders in the upload_folder
    based on an assignment of IP addresses to e-mail addresses from the json_file

    Args:
    pdf_folder (str): The path to the folder containing the PDF files to be organized.
    IP_Email_json (str): The path to the JSON file containing the mapping of IP addresses to email addresses.
    upload_folder (str): The path to the folder where the organized PDF files will be uploaded.

    Returns:
    None
    """

    # Create the upload_folder if it doesn't exist 
    if not os.path.exists(upload_folder):
        os.makedirs(upload_folder)

    # Read the json_file
    try:
        with open(IP_Email_json, "r") as file:
            IP_Email = json.load(file)
    except Exception as e:
        print(f"{IP_Email_json} file not found or contains an error: ", e)
        

    for pdf_file in os.listdir(pdf_folder):

        # Extract the IP address from the name of a PDF file by isolating the text between the last underscore and the last dot
        try:
            ip_address = pdf_file.rsplit("_", 1)[-1].rsplit(".", 1)[0]
        except Exception as e:
            print("IP address can't be extracted from the name of a PDF file :", e)

        # Search the extracted IP address in the json file to get the associated email address
        try:
            email = IP_Email[ip_address]
        except Exception as e:
            print(f"No email address found for IP address {ip_address}. Skipping file {pdf_file}.")
            
        # Create a subfolder for each email address in the upload folder if it doesn't exist
        email_folder = os.path.join(upload_folder, email)
        if not os.path.exists(email_folder):
            os.makedirs(email_folder)

        # Copy the PDF file to the email subfolder
        old_pdf_path = os.path.join(pdf_folder, pdf_file)
        new_pdf_path = os.path.join(email_folder, pdf_file)
        shutil.copy(old_pdf_path, new_pdf_path)

def create_tag(nc: nc_py_api.Nextcloud, tag_name: str) -> None:
    """
    The method creates a new tag in the Nextcloud if it doesn't already exist 

    Args:
    nc (nc_py_api.Nextcloud): An instance of the Nextcloud API client.
    tag_name (str): The name of the tag to be created.

    Returns:
    None
    """
    try:
        nc.files.create_tag(tag_name, user_visible=True, user_assignable=True)
    except Exception as e:
        print(f"The tag with the tag name {tag_name} already exists: ", e)


def prepare_zip_file(credentials: dict, upload_folder: str, email_subfolder: str) -> tuple:
    """
    The method creates an encrypted ZIP folder for a specific e-mail subfolder and generates a one-time secret link for the ZIP password.

    Args:
    credentials (dict): A dictionary containing access data for creating the one-time secret link.
    upload_folder (str): The path to the folder where the email subfolder and the ZIP file will be located.
    email_subfolder (str): The name of the email subfolder containing the files to be encrypted and zipped.

    Returns:
    tuple: A tuple containing the path to the newly created ZIP file and the one-time secret link for the ZIP password.

    """
    old_path = os.path.join(upload_folder, email_subfolder)
    new_zip_path = os.path.join(upload_folder, f"{email_subfolder}.zip")

    # Generate a random password for ZIP file encryption
    zip_password = generate_random_password()

    # Create a ZIP file with encryption
    create_zip_folder(old_path, new_zip_path, zip_password)
    # Create a one-time secret link for the ZIP password
    ots_zip_password_link = create_one_time_secret_link(zip_password, credentials)

    return new_zip_path, ots_zip_password_link

def create_zip_folder(source_folder: str, output_zip_path: str, password: str) -> None:
    """
    The method zips and encrypts the content of a source folder in a ZIP file
    The ZIP file will be encrypted with a random password

    Args:
    source_folder (str): The path to the folder whose content will be zipped and encrypted.
    output_zip_path (str): The path to the output ZIP file.
    password (str): The password used for encrypting the ZIP file.

    Returns:
    None
    """

    try:
        with pyzipper.AESZipFile(
            output_zip_path,
            "w",
            compression=pyzipper.ZIP_DEFLATED,
            encryption=pyzipper.WZ_AES,
        ) as zip_file:
            zip_file.pwd = password.encode()

            for root, dirs, files in os.walk(source_folder):
                for file in files:
                    file_path = os.path.join(root, file)
                    zip_file.write(file_path, os.path.relpath(file_path, source_folder))
    except Exception as e:
        print("Error creating ZIP folder: ", e)
  
def upload_and_send_emails(credentials: dict, nc: nc_py_api.Nextcloud, zip_file_path: str, email_subfolder: str, expiration_days: int, deletion_tag: str,  zip_password_link:str,  link_passwordzip_emailtext: str, passwordnextcloud_emailtext: str) -> tuple:
    """
    The method uploads the created ZIP folder, creates a link and password to the Nextcloud share
    and sends emails with the corresponding links and passwords

    Args:
    credentials (dict): A dictionary containing access data for sending emails and creating one-time secret links.
    nc (nc_py_api.Nextcloud): An instance of the Nextcloud API client.
    zip_file_path (str): The path to the created ZIP file.
    email_subfolder (str): The name of the email subfolder associated with the ZIP file.
    expiration_days (int): The number of days until the share link expires.
    deletion_tag (str): The tag used for marking files in Nextcloud for automatic deletion.
    zip_password_link (str): The one-time secret link for the ZIP password.
    link_passwordzip_emailtext (str): The email text containing the link and password for accessing the ZIP file.
    passwordnextcloud_emailtext (str): The email text containing the Nextcloud password.

    Returns:
    tuple: A tuple containing the Nextcloud link and the one-time secret link for the Nextcloud password.

    """
    
    # Upload the created ZIP file
    upload_file(nc, zip_file_path, f"{email_subfolder}.zip", deletion_tag)

    # Create a share link and password for Nextcloud
    expiration_date = datetime.now() + timedelta(days=expiration_days)
    nextcloud_file_url, password = create_link_with_password_to_NextCloud(nc, f"{email_subfolder}.zip", expiration_date)

    # Create a one-time secret link for the Nextcloud password
    ots_nextcloud_password = create_one_time_secret_link(password, credentials)

    # Send an email with the Nextcloud link and ZIP password (as an one-time secret link)
    send_link_and_zipPassword_email(credentials, email_subfolder, nextcloud_file_url, zip_password_link, expiration_date.strftime("%d.%m.%Y"), link_passwordzip_emailtext)

    # Send an email with the Nextcloud password (as an one-time secret link)
    send_NextcloudPassword_email(credentials, email_subfolder, ots_nextcloud_password, passwordnextcloud_emailtext)

    return nextcloud_file_url, ots_nextcloud_password


def upload_file(nc: nc_py_api.Nextcloud, file_name: str, nextcloud_file_name: str, deletion_tag:str) -> None:
    """
    The method uploads a file to the Nextcloud and adds a tag to the uploaded file
    The name of the file in the Nextcloud is defined by "nextcloud_file_name"

    Args:
    nc (nc_py_api.Nextcloud): An instance of the Nextcloud API client.
    file_name (str): The local file path of the file to be uploaded.
    nextcloud_file_name (str): The name of the file in the Nextcloud.
    deletion_tag (str): The tag to be added to the uploaded file for deletion management.

    Returns:
    None
    """    
    
    # List all files in the Nextcloud 
    all_files = nc.files.listdir(depth=1, exclude_self=False)

    # If a file with the same name in the Nextcloud already exists, exit the script
    if any(file.name == nextcloud_file_name for file in all_files):
        print(f"The file {nextcloud_file_name} already exists in the Nextcloud. The script will be canceled. Please delete the files in the Nextcloud and restart the script.")
        sys.exit()
    
    # If the file doesn't exist than upload the file with the nextcloud_file_name
    try:
        file_path = os.path.join(os.path.dirname(__file__), file_name)
        with open(file_path, "rb") as file_stream:
            nc.files.upload_stream(nextcloud_file_name, file_stream)
    except Exception as e:
        print("Error uploading file to Nextcloud: ", e)

    # Add a tag to the uploaded file
    add_tag(nc, deletion_tag, nextcloud_file_name)

def add_tag(nc: nc_py_api.Nextcloud, tag_name: str, file_name: str) -> None:
    """
    The method assigns a tag to a file in the Nextcloud

    Args:
    nc (nc_py_api.Nextcloud): An instance of the Nextcloud API client.
    tag_name (str): The name of the tag to be assigned.
    file_name (str): The name or path of the file in the Nextcloud.

    Returns:
    None

    """    
    try:
        file = nc.files.by_path(file_name)
        tag = nc.files.tag_by_name(tag_name)
        nc.files.assign_tag(file, tag)
    except Exception as e:
        print(f"Error adding tag with the tag name {tag_name} to file {file_name}: ", e)          


def create_link_with_password_to_NextCloud(nc: nc_py_api.Nextcloud, file_name: str, expiration_date: datetime) -> tuple:
    """
    The method generates a random password and creates a link to a specific file with an expiration date

    Args:
    nc (nc_py_api.Nextcloud): An instance of the Nextcloud API client.
    file_name (str): The name or path of the file in Nextcloud.
    expiration_date (datetime): The expiration date for the generated link.

    Returns:
    tuple: A tuple containing the generated share link URL and the random password used for encryption.

    """    

    # Generate a random password to encrypt the Nextcloud-Share
    nextcloud_password = generate_random_password()

    try:
        # Create the link with the chosen expiration date for the link to the file in the Nextcloud 
        sharing_api = nc_py_api.files.sharing._FilesSharingAPI(nc._session)
        kwargs = {"password": nextcloud_password, "expire_date": expiration_date}
        link = sharing_api.create(file_name, nc_py_api.files.sharing.ShareType.TYPE_LINK, **kwargs)

        return link.url, nextcloud_password
    
    except Exception as e:
        print("Error creating link with password to Nextcloud: ", e)
    
    
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--pdf-folder', prompt='Enter the path to the single_hosts folder of the Greenbone report', help='The folder contains the individual PDFs for each affected IP address.')
@click.option('--json-file', prompt='Enter the path to the IP_Email JSON-file', help='This json file contains mappings of IP addresses to email addresses.')
@click.option('--credentials-path', prompt='Enter the path to the credentials.txt file', default="schwachstellenmgmt\\templates\\credentials.txt", help='The file containing all credentials.',show_default=True)
@click.option('--expiration-days', prompt='Enter the number of days until the link to the file in the Nextcloud should expire ', default=14, type=int, help='Number of days until the link to the file in the Nextcloud expires.',show_default=True)
@click.option('--deletion-days', prompt='Enter the number of days until the files should be completely deleted from Nextcloud', default=14, type=int, help='Number of days until the files are completely deleted from Nextcloud.',show_default=True)
@click.option('--link_passwordzip_emailtext', prompt='Enter the path to a .txt file. The content is used for the email, which contains the link to the Nextcloud and a one-time link for the password of the ZIP file', default="schwachstellenmgmt\\templates\\link_passwordZIP_emailText.txt", help='Path to a .txt file. The content is used for the email, which contains the link to Nextcloud and a unique link for the password of the ZIP file. The email can be customized by using {nextcloud_file_url}, {zip_password_link} and {expiration_date}.',show_default=True)
@click.option('--passwordnextcloud_emailtext', prompt='Enter the path to a .txt file. The content is used for the email containing the one-time link for the password to the Nextcloud', default="schwachstellenmgmt\\templates\\passwordNextcloud_emailText.txt", help='Path to a .txt file. The content is used for the email, which contains the one-time link for the password to Nextcloud. The email can be individualized by using {nextcloud_password_link}.',show_default=True)
def main(pdf_folder: str, json_file: str, credentials_path: str, expiration_days: int, deletion_days: int, link_passwordzip_emailtext: str, passwordnextcloud_emailtext: str) -> None:
    """
    This program contacts the persons responsible for IP addresses affected by vulnerabilities via email. Communication takes place via the Nextcloud, an one-time secret and the sending of emails.
    """

    # Sort the PDFs by their email addresses
    # The upload_folder will contain all the sorted pdfs and zip files (exists only local)
    script_directory = os.path.dirname(__file__)
    upload_folder = os.path.join(script_directory, f"{datetime.now().date()}_upload_zip")
    sort_pdfs(pdf_folder, json_file, upload_folder)


    credentials = read_credentials(credentials_path)

    try:
        # Login to Nextcloud
        nc = nc_py_api.Nextcloud(
            nextcloud_url=credentials["nextcloud_url"],
            nc_auth_user=credentials["nc_auth_user"],
            nc_auth_pass=credentials["nc_auth_pass"],
        )
    except Exception as e:
        print(f"Error login to Nextcloud: {str(e)}")

    # Create the tag name based on the deletion tags
    deletion_tag_name = f"Greenbone Report {deletion_days}-days"
    create_tag(nc, deletion_tag_name)

    # Get a list of subdirectories in the upload folder
    email_subfolders = [folder for folder in os.listdir(upload_folder) if os.path.isdir(os.path.join(upload_folder, folder))]

    for email_subfolder in email_subfolders:
        # Prepare the ZIP file 
        # return the local path to the zip file in the upload_folder and the one-time secret to the password of the zip file
        zip_file_path, OTS_zip_password = prepare_zip_file(credentials, upload_folder, email_subfolder)

        # Upload the ZIP file and send emails
        nextcloud_file_url, OTS_nextcloud_password = upload_and_send_emails(credentials, nc, zip_file_path, email_subfolder, expiration_days, deletion_tag_name, OTS_zip_password, link_passwordzip_emailtext, passwordnextcloud_emailtext)

        print("_______________________________________")
        print("Receiver:", email_subfolder)
        print("Nextcloud Link:", nextcloud_file_url)
        print("OneTimeSecret_zip_password:",OTS_zip_password)
        print("OneTimeSecret_Nextcloud_Password:",OTS_nextcloud_password)