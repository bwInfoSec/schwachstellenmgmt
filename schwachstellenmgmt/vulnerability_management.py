import os
import shutil
import pyzipper
from datetime import datetime, timedelta
import nc_py_api
from schwachstellenmgmt.secret_functions import generate_random_password, create_one_time_secret_link
from schwachstellenmgmt.email_functions import send_NextcloudPassword_email, send_link_and_zipPassword_email
import shutil
import json
import click

CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"], show_default=True)

# Read the access data from the credentials.txt file
def read_credentials(credentials):
    try:
        with open(credentials, "r") as file:
            lines = file.readlines()
            credentials = {}
            for line in lines:
                key, value = line.strip().split("=")
                credentials[key] = value
            return credentials
    except Exception as e:
        print(f"credentials.txt file not found or contains an error:{str(e)}")
        

# The function organizes PDF files from the pdf_folder into subfolders in the upload_folder
# + based on an assignment of IP addresses to e-mail addresses from the json_file
def sort_pdfs(pdf_folder, json_file, upload_folder):
    if not os.path.exists(upload_folder):
        os.makedirs(upload_folder)


    try:
        with open(json_file, "r") as file:
            IP_Email = json.load(file)
    except Exception as e:
        print(f"{json_file} file not found or contains an error:{str(e)}")
        

    for pdf_file in os.listdir(pdf_folder):
        # Extract the IP address from a PDF file by isolating the text between the last underscore ("_") and the last dot (".")
        try:
            ip_address = pdf_file.rsplit("_", 1)[-1].rsplit(".", 1)[0]
        except Exception as e:
            print(f"IP address cannot be split:{str(e)}")
            

        # Search the extracted IP address in the json file to get the associated email address
        try:
            email = IP_Email[ip_address]
        except Exception as e:
            print(f"No email address found for IP address {ip_address}. Skipping file {pdf_file}.")
            
        
        # Create a subfolder for each email address in the upload folder
        email_folder = os.path.join(upload_folder, email)
        if not os.path.exists(email_folder):
            os.makedirs(email_folder)

        # Copy the PDF file to the email subfolder
        old_pdf_path = os.path.join(pdf_folder, pdf_file)
        new_pdf_path = os.path.join(email_folder, pdf_file)
        shutil.copy(old_pdf_path, new_pdf_path)
        

# The function uploads a file with the specified file name to the Nextcloud
# The name of the file in Nextcloud is defined by "nextcloud_file_name"
def upload_file(nc, file_name, nextcloud_file_name):
    try:
        file_path = os.path.join(os.path.dirname(__file__), file_name)
        with open(file_path, "rb") as file_stream:
            nc.files.upload_stream(nextcloud_file_name, file_stream)
    except Exception as e:
        print(f"Error uploading file to Nextcloud: {str(e)}")


# The function generates a random password, creates a link with an expiration date for the file
def create_link_with_password_to_NextCloud(nc, file_name, expiration_date):
    try:
        nextcloud_password = generate_random_password()

        sharing_api = nc_py_api.files.sharing._FilesSharingAPI(nc._session)
        kwargs = {"password": nextcloud_password, "expire_date": expiration_date}

        share = sharing_api.create(
            file_name, nc_py_api.files.sharing.ShareType.TYPE_LINK, **kwargs
        )
        return share.url, nextcloud_password
    except Exception as e:
        print(f"Error creating link with password to Nextcloud: {e}")
        


# The function zips and encrypts the contents of the source folder in a ZIP file with a password
def create_zip_folder(source_folder, output_zip_path, password):
    try:
        with pyzipper.AESZipFile(
            output_zip_path,
            "w",
            compression=pyzipper.ZIP_DEFLATED,
            encryption=pyzipper.WZ_AES,
        ) as zip_file:
            zip_file.pwd = password.encode()

            for root, dirs, files in os.walk(source_folder):
                for file in files:
                    file_path = os.path.join(root, file)
                    zip_file.write(file_path, os.path.relpath(file_path, source_folder))
    except Exception as e:
        print(f"Error creating ZIP folder: {str(e)}")
        


# The function creates ZIP files for each subdirectory in the upload_folder
# + encrypts them with random passwords
# + uploads them to the Nextcloud
# + sends two emails for each subdirectory
def zip_and_upload_Files(credentials, upload_folder, nc, expiration_date, passwordNextcloud_emailText, link_passwordZIP_emailText):
    # Get a list of subdirectories in the upload folder
    email_subfolders = [
        folder
        for folder in os.listdir(upload_folder)
        if os.path.isdir(os.path.join(upload_folder, folder))
    ]

    for email_subfolder in email_subfolders:
        old_path = os.path.join(upload_folder, email_subfolder)
        new_zip_path = os.path.join(upload_folder, f"{email_subfolder}.zip")

        # Generate a random password for ZIP file encryption
        # + create a ZIP file with encryption
        # + create a one-time secret link for the ZIP password
        zip_password = generate_random_password()
        create_zip_folder(old_path, new_zip_path, zip_password)
        zip_password_OTS_link = create_one_time_secret_link(zip_password, credentials)

        # Set the Nextcloud file name and upload the ZIP file
        nextcloud_file_name = f"{email_subfolder}.zip"
        upload_file(nc, new_zip_path, nextcloud_file_name)

        # Create a share link and password for Nextcloud
        # + create a one-time secret link for the Nextcloud password
        share_url, password = create_link_with_password_to_NextCloud(nc, nextcloud_file_name, expiration_date )
        share_password_OTS_link = create_one_time_secret_link(password, credentials)

        # Format the expiration date as dd.mm.yyyy
        formatted_expiration_date = expiration_date.strftime("%d.%m.%Y")

        # Send an email with the share link and ZIP password
        send_link_and_zipPassword_email(
            credentials,
            email_subfolder,
            "Security Vulnerability Scan Report - (Nextcloud Link and ZIP Password)",
            share_url,
            zip_password_OTS_link,
            formatted_expiration_date,
            link_passwordZIP_emailText
        )

        # Send an email with the Nextcloud share password
        send_NextcloudPassword_email(
            credentials,
            email_subfolder,
            "Security Vulnerability Scan Report - (Nextcloud Password)",
            share_password_OTS_link,
            passwordNextcloud_emailText
        )

        print("_______________________________________")
        print("Receiver:",email_subfolder)
        print("Share Link:",share_url)
        print("OneTimeSecret_zip_password:",zip_password_OTS_link)
        print("OneTimeSecret_Share_Password:",share_password_OTS_link)

def create_tag(nc: nc_py_api.Nextcloud, tag_name: str) -> None:
    try:
        nc.files.create_tag(tag_name, user_visible=True, user_assignable=True)
    except Exception as e:
        print(f"The tag already exists: {e}")
    return tag_name
        
# The function assigns a tag to all files in the root directory of the Nextcloud
def add_tags(nc, tag_name):
    try:
        tag = nc.files.tag_by_name(tag_name)

        all_files = nc.files.listdir("/")
        for file in all_files:
            nc.files.assign_tag(file, tag)
    except Exception as e:
        print(f"Error adding tags to files: {str(e)}")

@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--pdf-folder', prompt='Enter the path to the single_hosts folder of the Greenbone report', help='The folder contains the individual PDFs for each affected IP address.')
@click.option('--json-file', prompt='Enter the path to the IP_Email JSON-file', help='This json file contains mappings of IP addresses to email addresses.')
@click.option('--credentials-path', prompt='Enter the path to the credentials.txt file', default="schwachstellenmgmt\\templates\\credentials.txt", help='The file containing all credentials.')
@click.option('--expiration-days', prompt='Enter the number of days until the link to the file should expire on the Nextcloud', default=14, type=int, help='Number of days until the link to the file in the Nextcloud expires.')
@click.option('--deletion-days', prompt='Enter the number of days until the files should be completely deleted from Nextcloud', default=14, type=int, help='Number of days until the files are completely deleted from Nextcloud.')
@click.option('--link_passwordzip_emailtext', prompt='Enter the path to a .txt file. The content is used for the email, which contains the link to the Nextcloud and a one-time link for the password of the ZIP file', default="schwachstellenmgmt\\templates\\link_passwordZIP_emailText.txt", help='Path to a .txt file. The content is used for the email, which contains the link to Nextcloud and a unique link for the password of the ZIP file. The email can be customized by using {nextcloud_file_url}, {zip_password_link} and {expiration_date}.')
@click.option('--passwordnextcloud_emailtext', prompt='Enter the path to a .txt file. The content is used for the email containing the one-time link for the password to the Nextcloud', default="schwachstellenmgmt\\templates\\passwordNextcloud_emailText.txt", help='Path to a .txt file. The content is used for the email, which contains the one-time link for the password to Nextcloud. The email can be individualized by using {nextcloud_password_link}.')
def main(pdf_folder, json_file, credentials_path, expiration_days, deletion_days, link_passwordzip_emailtext, passwordnextcloud_emailtext ):

    """This program contacts the persons responsible for IP addresses affected by vulnerabilities via email. Communication takes place via the Nextcloud, an onetimesecret and the sending of emails."""

    try:

        credentials = read_credentials(credentials_path)

        try:
            # Login to Nextcloud
            nc = nc_py_api.Nextcloud(
                nextcloud_url=credentials["nextcloud_url"],
                nc_auth_user=credentials["nc_auth_user"],
                nc_auth_pass=credentials["nc_auth_pass"],
            )
        except Exception as e:
            print(f"Error login to Nextcloud: {str(e)}")

        # Create the tag name based on the deletion tags
        deletion_tag_name = f"Greenbone Report {deletion_days}-days"

        # Get or create the deletion tag in Nextcloud
        deletion_tag = create_tag(nc, deletion_tag_name)
            
        # Sort the PDFs by their email addresses
        script_directory = os.path.dirname(__file__)
        upload_folder = os.path.join(script_directory, f"{datetime.now().date()}_upload_zip")
        sort_pdfs(pdf_folder, json_file, upload_folder)

        # Zip and encrypt the folder with a password
        # + Upload the zip files to the Nextcloud (with a password for the Nextcloud share)
        # + Send emails
        expiration_date = datetime.now() + timedelta(days=expiration_days)
        zip_and_upload_Files(credentials, upload_folder, nc, expiration_date, passwordnextcloud_emailtext, link_passwordzip_emailtext)

        # Add tags to the uploaded files
        add_tags(nc, deletion_tag)

    except Exception as e:
        print(f"Error in user input: {str(e)}")


if __name__ == "__main__":
    click.echo("This program contacts the persons responsible for IP addresses affected by vulnerabilities via email. Communication takes place via the Nextcloud, an onetimesecret and the sending of emails.")
    main()


